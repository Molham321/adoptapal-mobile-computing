# Cloud-native Playground

## Quarkus Service: *unreliable-service*

New and simple Quarkus service generated by [project wizard](https://code.quarkus.io).
Contains some extensions like [Kotlin](https://quarkus.io/guides/kotlin), 
[RESTeasy Reactive](https://quarkus.io/guides/resteasy-reactive) or Kotlin serialization and uses 
[Gradle](https://quarkus.io/guides/gradle-tooling) as build tool.

Provides some [simple REST endpoints](https://quarkus.io/guides/resteasy-reactive) that are either blocking or 
non-blocking (reactive) - more on that later.

To start the service, switch to its folder and run `./gradlew quarkusDev`, which starts the service in development mode
that offers *hot reloading*.

### Dev UI

When running in dev mode, Quarkus services offer a development dashboard under 
[http://localhost:8080/q/dev](http://localhost:8080/q/dev) that offers nice insights into your application.

### Configuration

The main entry point for configuring a Quarkus application is the 
[`application.properties`](/unreliable-service/src/main/resources/application.properties) file under 
`<srv_root>/src/main/resources`. Some properties are build time dependent, others may be overwritten at startup time
using environment parameters (either as command line flags or via a `.env` file).

Config parameter may be assigned to specific *profiles*.

#### Profiles

A Quarkus application can be started by specifying a so-called config profile. For example, running the application
in dev mode (e.g. `./gradlew quarkusDev`) will automatically activate the **dev** profile. During unit tests, the 
**test** profile is active. And starting you application from a Docker image, the default **prod** profile is selected.

You may even define additional profiles as needed.

Based on the profile, config parameters might differ, which makes it rather easy to specify different values according
to the needs of the current runtime. For example, one might define different database parameters for production and 
development.

An example to define different root paths for your REST endpoints:

```config
quarkus.resteasy-reactive.path=/unreliable

%dev.quarkus.resteasy-reactive.path=/

%test.quarkus.resteasy-reactive.path=/
```

Note the prefixes **%dev** and **%test** which denote the corresponding profiles. Config parameters without a prefix are
your defaults and map to the **prod** profile.

More on configuring Quarkus can be found [here](https://quarkus.io/guides/config-reference).
For some insights on path resolution have a look at [this blog post](https://quarkus.io/blog/path-resolution-in-quarkus/).

### REST Endpoints

So far, the service contains four REST endpoints. Two return simple strings, the other two return a list of objects in 
JSON. They main difference lies in the actual return type - endpoints that return a *normal* data type like `String` are
executed blocking, meaning that the thread serving the request will pause and block until the results can be sent back.
This is/was the default for nearly all REST endpoints written with JAX-RS. 

However, Quarkus offers a new JAX-RS implementation, namely RESTeasy reactive, that is able to handle request in an
asynchronous, non-blocking manner by leveraging the capabilities of Vertx (a framework that does all the heavy lifting 
in a Quarkus application). To write such non-blocking endpoints, you must return a value of type 
[`Uni`](https://smallrye.io/smallrye-mutiny/1.7.0/tutorials/creating-uni-pipelines/) from 
[Mutiny framework](https://smallrye.io/smallrye-mutiny/1.7.0/). In doing so, Quarkus is able to process requests 
asynchronously without blocking the current I/O thread, thus freeing resources which should ultimately lead to faster
response times and more throughput.

More on RESTeasy execution model is described in [this guide](https://quarkus.io/guides/resteasy-reactive#execution-model).

More information on a reactive style with Quarkus in general can be found 
[here](https://quarkus.io/guides/getting-started-reactive).

## Docker

### Building JVM Image

Quarkus project come with a basic Dockerfile for building JVM-based images. However, those Dockerfiles depend on
running Gradle (or Maven) before. This is inconvenient, especially in cloud and CI/CD environments. The 
`Dockerfile.jvm` from this project is a multi-stage Dockerfile which first builds your application and afterwards 
creates an image containing only the application as well as runtime requirements.

To build such an image, just call `docker build -f src/main/docker/Dockerfile.jvm -t unreliable-service-jvm .`.

### Building Native Image

Beside creating JVM-based images, Quarkus also allows for creating native (e.g. GraalVM based) images. Just call
`docker build -f src/main/docker/Dockerfile.native-micro-multistage -t unreliable-service-native .` to create one.

**Note:** Currently, building native images doesn't work on Apple Silicon out of the box. See 
[StackOverflow](https://stackoverflow.com/questions/67337504/issue-compiling-quarkus-native-image-on-apple-sillicon/71368601#71368601) 
for a workaround.

## Docker Compose 

`docker compose up`

docker-compose up -d --build --force-recreate


docker-compose scale unreliable-service=3

docker-compose down

### Traefik Reverse Proxy

Traefik Dashboard available at [http://localhost/dashboard](http://localhost/dashboard)

### Quarkus Service

## IDE Configuration

